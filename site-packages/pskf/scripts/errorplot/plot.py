from matplotlib import colors
import numpy as np
import matplotlib.pyplot as plt

from pskf.tools.run import pythonmodule as pm
from pskf.tools.plot import plotarrays as pa

from pskf.scripts.errorplot import arrays as ea


###############################################################################
#                          Errorplot RMSE point plot                          #
###############################################################################
def plot(
        ax,
        which_methods=[0, 1, 2, 3, 4, 5, 6],
        which_res='endres',
        stat_method='mean',
        ensemble_sizes=[50, 70, 100, 250],
        axistitle='',
        model='wavebc',
        is_std=False,
        lineyval=0.62,
        std_method='std',
        pic_format='pdf',
        figpos=[0.15, 0.3, 0.8, 0.6],
        xlim_min=0,
        xlim_max=None,
        ylims=[0.28, 0.82],
        is_textpos_auto=True,
        textpos=[0.7, 0.6, 0.5, 0.4],
        xdiff_nens=0.5,
        yticks=[0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1],
        ylabel=r'RMSE  $\log(K[\mathrm{m}^2])$',
        num_pack=4,  # Number of methods in pack
        is_text=False,
        text_x=0.5,
        text_y=0.5,
        n_syn=1000,
        legend_input=None,
        formatsos=['o', 'v', 's', 'p',
                   'o', 'v', 's', 'p',
                   'o', 'v', 's', 'p',
                   'o', 'v', 's', 'p',
                   'o', 'v', 's', 'p',
                   'o', 'v', 's', 'p',
                   'o', 'v', 's', 'p',
                   'o', 'v', 's', 'p'],
        coleros=[(0.0, 0.0, 0.0), (0.0, 0.0, 0.0),
                 (0.0, 0.0, 0.0), (0.0, 0.0, 0.0),
                 (1.0, 1.0, 1.0), (1.0, 1.0, 1.0),
                 (1.0, 1.0, 1.0), (1.0, 1.0, 1.0),
                 (0.0, 0.0, 0.0), (0.0, 0.0, 0.0),
                 (0.0, 0.0, 0.0), (0.0, 0.0, 0.0),
                 (1.0, 1.0, 1.0), (1.0, 1.0, 1.0),
                 (1.0, 1.0, 1.0), (1.0, 1.0, 1.0),
                 (0.0, 0.0, 0.0), (0.0, 0.0, 0.0),
                 (0.0, 0.0, 0.0), (0.0, 0.0, 0.0),
                 (1.0, 1.0, 1.0), (1.0, 1.0, 1.0),
                 (1.0, 1.0, 1.0), (1.0, 1.0, 1.0),
                 (0.0, 0.0, 0.0), (0.0, 0.0, 0.0),
                 (0.0, 0.0, 0.0), (0.0, 0.0, 0.0),
                 (1.0, 1.0, 1.0), (1.0, 1.0, 1.0),
                 (1.0, 1.0, 1.0), (1.0, 1.0, 1.0)],
        markersize=[10 for i in range(32)],
        markeredgesize=1.5,
        fontleg=30,
        fonttit=40,
        fontlab=40,
        fonttic=30,
):
    """
    A plotting function for statistics of residual distributions.

    Parameters
    ----------
    ax : Axes
        The axes to draw to.

    which_methods : array int
        Array of integers containing the method specifiers
        from module plotarrays.
        The methods appear in the plot in this order.

    which_res : string
        'endres' - use residuals after EnKF run
        'begres' - use residuals before EnKF run

    stat_method : string
        'mean' - Means
        'std' - Standard deviation
        'stdm' - Standard deviation of the mean
        'median' - Median or 50 Percentile
        'q25' - 25 Percentile
        'q75' - 75 Percentile

    ensemble_sizes : array of integers
        array can typically contain 50, 70, 100, 250,
        500, 1000, 2000

    model : string
        'wavebc' - Model wavebc
        'wave' - Model wave

    is_std : boolean
        True - Show errorbars of standard deviation
        False - No errorbars

    std_method : string
        Standard deviation to use
        'std' - Standard deviation
        'stdm' - Standard deviation of mean

    pic_format : string
        Format of the picture
        'pdf' - pdf-format
        'eps' - eps-format
        'png' - png-format
        'jpg' - jpg-format
        'svg' - svg-format

    figpos : array of floats
        Four numbers
        xbeg, ybeg, xrange, yrange

    More input specifying plot parameters.

    Returns
    -------
    ax : Axes
        Axes containing plot.

    pic_name : string
        Containing proposed saving location for Figure.
    """

    # Check
    for enssize in ensemble_sizes:
        if enssize not in [50, 70, 100, 250, 500, 1000, 2000]:
            raise exceptions.RuntimeError(
                'Wrong ensemble size.'
                )

    # Title
    ax.set_title(axistitle, size=fonttit)

    # Number of methods
    num_methods = len(which_methods)

    # Default legend input
    if legend_input is None:
        legend_input = pa.longnames_methods
        legend_input = np.array([legend_input[i].ljust(18)
                                 for i in which_methods])

    # Load residuals
    res = np.load(pm.py_output_filename(
        'errorplot',
        which_res,
        stat_method+'_'+model+'_'
        + '_'.join([str(enssize) for enssize in ensemble_sizes])+'_'
        + '_'.join([str(i) for i in which_methods]),
        'npy'
    ))

    # Load standard deviation
    if is_std:
        std = np.load(pm.py_output_filename(
            'errorplot',
            which_res,
            std_method+'_'+model+'_'
            + '_'.join([str(enssize) for enssize in ensemble_sizes])+'_'
            + '_'.join([str(i) for i in which_methods]),
            'npy'))

    ax.set_prop_cycle("color", ['k'])
    ax.set_position(figpos)

    for iens, enssize in enumerate(ensemble_sizes):
        # x positions, up to 15 methods
        x = np.delete(np.arange(0, 100),
                      np.arange(0, 100, num_pack+1))
        # Skip one after num_pack+1 entries for vertical line

        resplot = res[:, iens]
        if is_std:
            stdplot = std[:, iens]

        # Plot
        puntos = []                            # Contains plotted points
        ax.plot(x[:len(resplot)], resplot, 'k-', label=3)
        for iplot in range(num_methods):
            # Points
            punto, = ax.plot(
                x[iplot],
                resplot[iplot],
                formatsos[iplot],
                lw=2,
                ms=markersize[iplot],
                label=legend_input[iplot],
                c=coleros[iplot], mew=markeredgesize
            )
            puntos.append(punto)

            # Text
            if iplot == num_methods-1:
                ax.text(
                    x[iplot]+xdiff_nens,
                    resplot[iplot] if is_textpos_auto else textpos[iens],
                    r'$n_{e}$='+str(enssize),
                    verticalalignment='center',
                    horizontalalignment='left',
                    size=20,
                )

            # Error
            if is_std:
                ax.errorbar(
                    x[iplot],
                    resplot[iplot],
                    yerr=stdplot[iplot],
                    fmt=formatsos[iplot],
                    lw=2,
                    ms=markersize[iplot],
                    label='this',
                    mfc=coleros[iplot],
                    mew=markeredgesize,
                    mec='black'
                )

    # Legend
    num_inleg = num_pack    # Methods per legend (except last)
    num_legs = int(num_methods/num_inleg
                   + int(bool(np.mod(num_methods,
                                     num_inleg))))  # Number of legends
    num_inlastleg = (np.mod(num_methods, num_inleg)
                     if np.mod(num_methods, num_inleg) else
                     num_inleg)  # Methods in last legend
    leginds = [num_inleg-1+i*num_inleg
               if i < num_legs-1 else
               num_inleg-1+(i-1)*num_inleg+num_inlastleg
               for i in range(num_legs)]  # last method ind in each legend
    legranges = [num_inleg if i < num_legs-1 else num_inlastleg
                 for i in range(num_legs)]  # Methods in each legend

    for ileg in range(num_legs):
        xleg = figpos[0] + ileg*figpos[2]/num_legs
        my_legend = ax.legend(
            handles=[puntos[i]
                     for i in range(leginds[ileg]-legranges[ileg]+1,
                                    leginds[ileg]+1)],
            bbox_to_anchor=[xleg,
                            0.00,
                            figpos[2]/num_legs,
                            0.3],
            bbox_transform=plt.gcf().transFigure,
            # loc=[0.0, 1.0],
            mode='expand',
            # labelspacing=1.0,
            ncol=1,
            numpoints=1,
            fontsize=fontleg,
            framealpha=1.0,
            markerscale=1.0
        )
        ax.add_artist(my_legend)

    # Lines
    for xline in range(0, 100, num_pack+1):
        ax.vlines(xline, 0.0, 1.0, linestyles='dotted')

    for yline in yticks:
        ax.hlines(yline, 0, 100, linestyles='dotted')

    ax.hlines(lineyval, 0, 100, linestyles='dashed')

    # Text: Model name and n_syn in box
    if is_text:
        model_spec = '  Tracer  ' if model == 'wavereal' else '   Well   '
        ax.text(
            text_x, text_y,
            model_spec+'\n'
            + r' $n_{syn}$: '+str(n_syn).rjust(4),
            linespacing=1.5,
            fontsize=30,
            bbox={'facecolor': (0.8, 0.8, 0.8), 'alpha': 1.0, 'pad': 10},
        )

    # Style
    ax.set_xlim([xlim_min, (num_legs*(num_pack+1) if xlim_max is None
                            else xlim_max)])
    ax.set_ylabel(ylabel,
                  fontsize=fontlab,
                  labelpad=10)
    ax.tick_params(direction='in', length=6,
                   width=1, labelsize=fonttic,
                   top='off', right='off', bottom='off',
                   pad=8)
    ax.set_xticks([])
    ax.set_yticks(yticks)
    ax.get_xaxis().set_visible('off')
    ax.set_ylim(ylims)

    # Saving location
    pic_name = pm.py_output_filename(
        ea.tag,
        which_res,
        stat_method+'_'+model+'_'
        + '_'.join([str(enssize) for enssize in ensemble_sizes])+'_'
        + '_'.join([str(i) for i in which_methods]),
        pic_format
    )

    return ax, pic_name


###############################################################################
#                          Matrix plot of RMSE quotients                      #
###############################################################################
def quots(
        ax,
        which_methods=[0, 1, 2, 3, 4, 5, 6],
        which_res='endres',
        stat_method='mean',
        model='wavebc',
        ensemble_sizes=[50, 70, 100, 250],
        ensemble_size=50,
        pic_format='pdf',
        is_text=False,
        axistitle='',
        fonttit=40,
        figpos=[0.32, 0.2, 0.6, 0.8],
        ticksize=20,
):
    """
    A function plotting a grid of quotients of
    statistical measures.

    Parameters
    ----------
    ax : Axes
        The axes to draw to.

    which_methods : array int
        Array of integers containing the method specifiers
        from module plotarrays.
        The methods appear in the plot in this order.

    which_res : string
        'endres' - use residuals after EnKF run
        'begres' - use residuals before EnKF run

    stat_method : string
        'mean' - Means
        'std' - Standard deviation
        'stdm' - Standard deviation of the mean
        'median' - Median or 50 Percentile
        'q25' - 25 Percentile
        'q75' - 75 Percentile

    model : string
        'wavebc' - Model wavebc
        'wave' - Model wave

    ensemble_sizes : array of integers
        array can typically contain 50, 70, 100, 250,
        500, 1000, 2000

    ensemble_size : integer
        Ensemble size of the job. Possibilities: 50,
        70, 100, 250, 500, 1000, 2000

    pic_format : string
        Format of the picture
        'pdf' - pdf-format
        'eps' - eps-format
        'png' - png-format
        'jpg' - jpg-format
        'svg' - svg-format

    figpos : array of floats
        Four numbers
        xbeg, ybeg, xrange, yrange

    More input specifying plot parameters.

    Returns
    -------
    ax : Axes
        Axes containing quotient matrix.

    pic_name : string
        Containing proposed saving location for Figure.
    """

    # Check
    if ensemble_size not in [50, 70, 100, 250, 500, 1000, 2000]:
        raise exceptions.RuntimeError('ensemble_size wrong')

    # Title
    ax.set_title(axistitle, size=fonttit)

    # Number of compared methods
    num_methods = len(which_methods)

    # Ensemble size translated to index
    iens = pa.indens[model][ensemble_size]

    # Load residuals
    res = np.load(pm.py_output_filename(
        'errorplot',
        which_res,
        stat_method+'_'+model+'_'
        + '_'.join([str(enssize) for enssize in ensemble_sizes])+'_'
        + '_'.join([str(i) for i in which_methods]),
        'npy'))

    # Calculate and sort quots
    quots = np.array(
        [[res[i1, iens]/res[i2, iens] for i1 in range(num_methods)]
         for i2 in range(num_methods)]
        )

    ax.set_position(figpos)

    # White Rectangles
    for ipm in range(num_methods):
        for jpm in range(num_methods):
            # Diagonal black
            if ipm == jpm:
                quots[ipm, jpm] = 0.0
            # Upper triangle white
            if ipm < jpm:
                quots[ipm, jpm] = None

    ax.imshow(
        quots,
        interpolation='nearest',
        cmap='Greys_r',
        norm=colors.Normalize(vmin=0.8, vmax=1.0, clip=False)
    )

    # Plot: Mostly ticks
    ax.set_xticks([i for i in range(num_methods)])
    ax.set_xticklabels([pa.names_methods[which_methods[i]]
                        for i in range(len(which_methods))],
                       fontsize=ticksize,
                       rotation=90)
    ax.set_yticks([i for i in range(num_methods)])
    ax.set_yticklabels([pa.names_methods[which_methods[i]]
                        for i in range(len(which_methods))],
                       fontsize=ticksize)
    ax.tick_params(length=0)
    ax.set_frame_on(False)

    # Text
    for itext in range(num_methods):
        for jtext in range(num_methods):
            if itext < jtext:
                ntext = quots[jtext, itext]
                ttext = str(ntext)[0:4]
                px = itext-0.35
                py = jtext+0.15
                colero = 'white' if ntext < 0.9 else 'black'

                ax.text(px, py, ttext, color=colero, fontsize=25)

    # Text: n_syn and ensemble_size
    if is_text:
        model_spec = '  Tracer  ' if model == 'wavereal' else '   Well   '
        ax.text(
            3.5, 1.5,
            model_spec+'\n'
            + r' $n_{e}$: '+str(ensemble_size).rjust(4),
            linespacing=1.5,
            fontsize=30,
            bbox={'facecolor': 'grey', 'alpha': 0.5, 'pad': 10},
        )

    # Saving location
    pic_name = pm.py_output_filename(
        ea.tag,
        'quots_'+which_res,
        stat_method+'_'+model+'_'
        + str(ensemble_size)+'_'
        + '_'.join([str(i) for i in which_methods]),
        pic_format)

    return ax, pic_name
