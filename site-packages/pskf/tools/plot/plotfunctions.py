"""
plotfunctions
=============

Functions for reading vtk output.

Functions for generating various figure components.
"""
import os
import shlex

import numpy as np
import matplotlib as mpl
import matplotlib.cm as cm

import vtk
from vtk.util.numpy_support import vtk_to_numpy
import h5py
from pskf.tools.run import runmodule as rm
from pskf.tools.run import pythonmodule as pm
from pskf.tools.plot import plotarrays as pa
from pskf.tools.plot import specs as sc
from pskf.scripts.errorplot import read as er

import string

alphabet = string.ascii_lowercase


###############################################################################
#                                 my_vtk                                      #
###############################################################################
def my_vtk(fdir, fname, varname):
    """
    Get vtk-reader from filename and varname

    Parameters
    ----------
    fdir : string
        Path to the file. Without '/' at end.

    fname : string
        Name of the file.

    varname: string
        Name of the variable

    Returns
    ----------
    vtk_reader: vtk Reader instance
        vtk Reader containing information about a vtk-file.
    """

    # Check if scalar variable is in vtk-file
    is_var_in_file(fdir, fname, varname)

    # Prepare vtk-Reader
    vtk_reader = vtk.vtkRectilinearGridReader()  # Reader
    vtk_reader.SetFileName(fdir + '/' + fname)  # Filename
    vtk_reader.SetScalarsName(varname)  # Variable name
    vtk_reader.Update()  # Refresh

    return vtk_reader


def my_vtk_to_numpy(vtk_reader):
    """
    Read array from vtk_reader and output as numpy array.

    Parameters
    ----------
    vtk_reader: vtk Reader instance
        vtk Reader containing information about a vtk-file.

    Returns
    ----------
    numpy_array: Numpy array
        Numpy array containing the variable array corresponding to
        the vtk_reader.
    """

    vtk_output = vtk_reader.GetOutput()

    # Grid properties
    grid_dimens = vtk_output.GetDimensions()  # Grid Dimensions
    grid_bounds = vtk_output.GetBounds()  # Grid Bounds

    # Reshape array to grid geometry
    if grid_bounds[0] == 0.0:  # CELLS
        vtk_array = vtk_output.GetCellData().GetArray(0)
        # vtk_to_numpy and reshape
        numpy_array = vtk_to_numpy(vtk_array)
        numpy_array = numpy_array.reshape(
            grid_dimens[0] - 1,
            1 if grid_dimens[1] == 1 else grid_dimens[1] - 1)
    else:  # POINTS
        vtk_array = vtk_output.GetPointData().GetArray(0)
        # vtk_to_numpy and reshape
        numpy_array = vtk_to_numpy(vtk_array)
        if vtk_reader.GetScalarsName() == 'v':
            numpy_array = numpy_array.reshape(grid_dimens[0], grid_dimens[1],
                                              3)
            numpy_array[:, :, 2] = np.sqrt(numpy_array[:, :, 0]**2 +
                                           numpy_array[:, :, 1]**2)
        else:
            if grid_dimens[0] > 1 and grid_dimens[1] > 1:
                if grid_dimens[2] > 1:  # 3D
                    numpy_array = numpy_array.reshape(
                        grid_dimens[2], grid_dimens[1], grid_dimens[0])
                    numpy_array = np.transpose(numpy_array, [2, 1, 0])
                else:  # 2D horizontal
                    numpy_array = numpy_array.reshape(grid_dimens[1],
                                                      grid_dimens[0])
                    numpy_array = np.transpose(numpy_array, [1, 0])
            elif grid_dimens[0] > 1 and grid_dimens[2] > 1:  # 2D vertical
                numpy_array = numpy_array.reshape(grid_dimens[2],
                                                  grid_dimens[0])
            else:
                raise exceptions.RuntimeError('Shape of array wrong: ' +
                                              str(grid_dimens))

    return numpy_array


def my_vtk_coords(vtk_reader, coord):
    """
    Get array of x-coordinates, y-coordinates, or z-coordinates
    from vtk_reader instance.

    Parameters
    ----------
    vtk_reader: vtk Reader instance
        vtk Reader containing information about a vtk-file.

    coord : string
        'x', 'y', or 'z' depending on the wanted coordinate directin.

    Returns
    ----------
    numpy_coord : NumPy Array
        array of x-coordinates, y-coordinates, or z-coordinates.

    """

    if coord not in ['x', 'y', 'z']:
        raise exceptions.RuntimeError(
            'coord input needs to be "x", "y", or "z"')

    vtk_output = vtk_reader.GetOutput()

    vtk_coord = (vtk_output.GetXCoordinates() if coord == 'x' else
                 (vtk_output.GetYCoordinates() if coord == 'y' else
                  (vtk_output.GetZCoordinates() if coord == 'z' else [])))

    numpy_coord = vtk_to_numpy(vtk_coord)

    return numpy_coord


def my_vtk_p_dist(vtk_reader, i1, j1, k1, i2, j2, k2):
    """
    Get distance between two points in SHEMAT-Suite model
    from indices and vtk_reader instance.

    Be sure to use SHEMAT-Suite indices!

    Parameters
    ----------
    vtk_reader: vtk Reader instance
        vtk Reader containing information about a vtk-file.

    i1 : integer
        SHEMAT-Suite i-index of first point

    j1 : integer
        SHEMAT-Suite j-index of first point

    k1 : integer
        SHEMAT-Suite k-index of first point

    i2 : integer
        SHEMAT-Suite i-index of second point

    j2 : integer
        SHEMAT-Suite j-index of second point

    k2 : integer
        SHEMAT-Suite k-index of second point

    Returns
    ----------
    dist : float
        distance between points in [m].

    """
    x = my_vtk_coords(vtk_reader, 'x')
    y = my_vtk_coords(vtk_reader, 'y')
    z = my_vtk_coords(vtk_reader, 'z')

    dist = np.sqrt((x[i1 - 1] - x[i2 - 1])**2 + (y[j1 - 1] - y[j2 - 1])**2 +
                   (z[k1 - 1] - z[k2 - 1])**2)

    return dist


def my_vtk_grid_props(vtk_reader):
    """
    Get grid properties from vtk_reader instance.

    Parameters
    ----------
    vtk_reader: vtk Reader instance
        vtk Reader containing information about a vtk-file.

    Returns
    ----------
    step_x : float
        For regular grid, stepsize in x-direction.

    step_y : float
        For regular grid, stepsize in y-direction.

    npts_x : float
        Number of cells in x-direction.

    npts_y : float
        Number of cells in y-direction.

    low_m_x : float
        Middle of first x cell

    high_m_x : float
        Middle of last x cell

    low_m_y : float
        Middle of first y cell

    high_m_y : float
        Middle of last y cell

    low_x : float
        Edge of first x cell

    high_x : float
        Edge of last x cell

    low_y : float
        Edge of first y cell

    high_y : float
        Edge of last y cell

    Notes
    ----------
    0: step_x
    1: step_y
    2: npts_x
    3: npts_y
    4: low_m_x - Middle of cells: first x cell
    5: high_m_x - Middle of cells: last x cell
    6: low_m_y - Middle of cells: first y cell
    7: high_m_y - Middle of cells: last y cell
    8: low_x - Edge of cells: first x cell
    9: high_x - Edge of cells: last x cell
    10: low_y - Edge of cells: first y cell
    11: high_y - Edge of cells: last y cell
    """

    vtk_output = vtk_reader.GetOutput()

    # Read attributes of the vtk-Array
    # num_cells = vtk_output.GetNumberOfCells()
    # num_points = vtk_output.GetNumberOfPoints()
    # whole_extent = vtk_output.GetExtent()
    grid_bounds = vtk_output.GetBounds()
    grid_dims = vtk_output.GetDimensions()

    # Grid information
    step_x = (grid_bounds[1] - grid_bounds[0]) / (grid_dims[0] - 1)
    step_y = (grid_bounds[3] - grid_bounds[2]) / (grid_dims[1] - 1)
    if grid_bounds[0] == 0.0:  # CELLS
        npts_x = grid_dims[0] - 1
        npts_y = grid_dims[1] - 1
        low_m_x = grid_bounds[0] + 0.5 * step_x
        high_m_x = grid_bounds[1] - 0.5 * step_x
        low_m_y = grid_bounds[2] + 0.5 * step_y
        high_m_y = grid_bounds[3] - 0.5 * step_y
        low_x = grid_bounds[0]
        high_x = grid_bounds[1]
        low_y = grid_bounds[2]
        high_y = grid_bounds[3]
    else:  # POINTS
        npts_x = grid_dims[0]
        npts_y = grid_dims[1]
        low_m_x = grid_bounds[0]
        high_m_x = grid_bounds[1]
        low_m_y = grid_bounds[2]
        high_m_y = grid_bounds[3]
        low_x = grid_bounds[0] - 0.5 * step_x
        high_x = grid_bounds[1] + 0.5 * step_x
        low_y = grid_bounds[2] - 0.5 * step_y
        high_y = grid_bounds[3] + 0.5 * step_y

    return step_x, step_y, \
        npts_x, npts_y, \
        low_m_x, high_m_x, low_m_y, high_m_y, \
        low_x, high_x, low_y, high_y


def my_vtk_make_quiver(vtk_reader, ax, scale=None):
    """
    Read a field of arrows from vtk-file and insert it in axis.

    Parameters
    ----------
    vtk_reader: vtk Reader instance
        vtk Reader containing information about a vtk-file.

    ax : Axes
        The axes to draw to.

    Returns
    -------
    ax : array
        Axes containing plot.

    Notes
    -------
    Only regular grids supported!
    """
    # Quiver
    vtk_output = vtk_reader.GetOutput()

    # 1:Get Vector quantitiy
    v_vtk = vtk_output.GetPointData().GetArray(0)

    # Get grid properties
    (step_x, step_y, npts_x, npts_y, low_m_x, high_m_x, low_m_y,
     high_m_y) = my_vtk_grid_props(vtk_reader)[:8]

    # Generate regular grid, incl last cell
    x = np.arange(low_m_x, high_m_x + 1, step_x)
    y = np.arange(low_m_y, high_m_y + 1, step_y)
    X, Y = np.meshgrid(x, y)

    # vtk file to NumPy array
    v = vtk_to_numpy(v_vtk)

    # Vector components reshaped to grid
    vx = v[:, 0].reshape(npts_x, npts_y)
    vy = v[:, 1].reshape(npts_x, npts_y)

    # Arrows to axis
    ax.quiver(X, Y, vx, vy, scale=scale)

    return ax


def is_var_in_file(path,
                   fname,
                   var,
                   raise_io_error=1,
                   raise_var_error=1,
                   only_scalar=0,
                   only_vector=0):
    """
    Checks the existence of the file and whether var is a variable
    inside the file. Output: 1 if it is inside, 0 if it is not.
    By default, exceptions are raised if the variable is not inside
    the file.
    """
    # Check existence of file.
    try:
        f = open(path + '/' + fname, 'r')
    except IOError:
        if raise_io_error:
            print('\n' + path + '\n')
            raise
        else:
            return 0

    # Check if variable is SCALAR and in file.
    if not only_vector:
        for line in f:
            if line.find('SCALARS ' + var) > -1:
                f.close()
                return 1
            elif line.find('SCALARS  ' + var) > -1:
                f.close()
                return 1
            elif line.find('SCALARS   ' + var) > -1:
                f.close()
                return 1
            elif line.find('SCALARS    ' + var) > -1:
                f.close()
                return 1
    f.seek(0)
    # Check if variable is VECTOR and in file.
    if not only_scalar:
        for line in f:
            if line.find('VECTORS ' + var) > -1:
                f.close()
                return 1
            elif line.find('VECTORS  ' + var) > -1:
                f.close()
                return 1
            elif line.find('VECTORS   ' + var) > -1:
                f.close()
                return 1
            elif line.find('VECTORS    ' + var) > -1:
                f.close()
                return 1
    if raise_var_error:
        raise exceptions.RuntimeError(var + ' not in ' + fname + '\n Dir: ' +
                                      path)
    else:
        return 0


###############################################################################
#                                   cmap                                      #
###############################################################################
def cmap_discretize(cmap, N):
    """Return a discrete colormap from the continuous colormap cmap.

        cmap: colormap instance, eg. cm.jet.
        N: number of colors.

    Example
        x = resize(arange(100), (5,100))
        djet = cmap_discretize(cm.jet, 5)
        imshow(x, cmap=djet)
    """

    if type(cmap) == str:
        cmap = cm.get_cmap(cmap)
    colors_i = np.concatenate((np.linspace(0, 1., N), (0., 0., 0., 0.)))
    colors_rgba = cmap(colors_i)
    indices = np.linspace(0, 1., N + 1)
    cdict = {}
    for ki, key in enumerate(('red', 'green', 'blue')):
        cdict[key] = [(indices[i], colors_rgba[i - 1, ki], colors_rgba[i, ki])
                      for i in xrange(N + 1)]
    # Return colormap object.
    return mpl.colors.LinearSegmentedColormap(cmap.name + "_%d" % N, cdict,
                                              1024)


###############################################################################
#                                colorbar                                     #
###############################################################################
def cb(
        cb_ax,
        ax,
        varname="uindex",
        varlabels={
            'temp': r'Temperature [$^{\circ}\mathrm{C}$]',
            'head': r'$\mathrm{h}$ [$\mathrm{m}$] - $10\, \mathrm{m}$',
            'uindex': r'Unit Index',
            'kz': r'$\log(K[\mathrm{m}^2])$',
            'kz_mean': r'$\log(K[\mathrm{m}^2])$',
            'tracer1': r'Concentration [$\frac{\mathrm{mol}}{\mathrm{l}}$]',
            'lz': r'$\lambda$ [$\frac{W}{m\, K}$]',
        },
        cb_ax_position=[0.8, 0.1, 0.03, 0.8],
        label_position='title',
        ticklabelsize=20,
        labelsize=40,
        labelpad=1.0):
    """
    Add colorbar to figure.

    Parameters
    ----------
    cb_ax : Axes
        Empty colorbar-Axes instance.

    ax : Axes
        The axes holding the colored image.

    label_position : string
        Determines the position of the colorbar label. Should be 'title',
        'x' or 'y'.

    Returns
    -------
    cb_ax : Axes
        Colobar-Axes instance including the colorbar.
    """

    im = ax.images[0]

    # colorbar
    mpl.colorbar.Colorbar(cb_ax, im)

    # Axis configuration
    cb_ax.set_position(cb_ax_position)
    cb_ax.tick_params(labelsize=ticklabelsize)
    if label_position == 'title':
        cb_ax.set_title(varlabels[varname], y=labelpad, fontsize=labelsize)
    elif label_position == 'x':
        cb_ax.set_xlabel(
            varlabels[varname], labelpad=labelpad, fontsize=labelsize)
    elif label_position == 'y':
        cb_ax.set_ylabel(
            varlabels[varname], labelpad=labelpad, fontsize=labelsize)
    else:
        raise exceptions.RuntimeError('label_position wrong: ' +
                                      label_position)

    # Special uindex labels
    if varname == 'uindex':
        cb_ax.yaxis.set_ticklabels([
            "1: sand", "2: sand", "3: water", "4: water", "5: water",
            "6: water", "7: cement"
        ])

    return cb_ax


###############################################################################
#                                 Scatter Plot                                #
###############################################################################
def scatter(
        ax,
        model_name,
        dat,
        let,
        is_ownlocs=False,
        ownlocs=[[1, 1, 1]],
        loc_inds=range(1),
        marker='o',
        markersize=50,
        markercolor='black',
        markeralpha=1.0,
):
    """
    Scatter plot of SHEMAT-Suite monitoring points.

    Parameters
    ----------
    ax : Axes
        The axes to draw to.

    model_name : string
        String of model name.
        'wavebc' - Model wavebc
        'wavereal' - Model wavereal
        'wavewell' - Model wavewell
        'wave' - Model wave

    dat : string
        String with date of model run.

    let : string
        String of letter of model run.

    Returns
    -------
    ax : Axes
        Axes containing scatter plots.

    Notes
    -------
    Could at some point be generalized to x-z arrays.
    """

    # Grid
    x = sc.x(model_name, dat, let)
    y = sc.y(model_name, dat, let)

    # Read
    if is_ownlocs:
        locs = np.array(ownlocs)
    else:
        locs = np.array(sc.monitor_locs(model_name, dat, let))

    # Scatterplot
    ax.scatter(
        x[locs[loc_inds][:, 0] - 1],
        y[locs[loc_inds][:, 1] - 1],
        marker=marker,
        c=markercolor,
        edgecolors=markercolor,
        alpha=markeralpha,
        s=markersize)

    return ax


###############################################################################
#                                   movie                                     #
###############################################################################
def movie(input_name_test='plot_m_b_01_100_av.png',
          input_names='plot_m_b_%02d_100_av.png',
          output_name='plot_m_b_100_av.mp4',
          pics_dir='None'):

    # Test for Directory
    if pics_dir == 'None':
        raise exceptions.RuntimeError('No directory specified')

    # Absolute path file names
    input_name_test_abs = pics_dir + '/' + input_name_test
    input_names_abs = pics_dir + '/' + input_names
    output_name_abs = pics_dir + '/' + output_name

    # Test for specific input file
    if not os.path.isfile(input_name_test_abs):
        raise exceptions.RuntimeError('FILE' + input_name_test_abs +
                                      ' not found!!!')
    # Delete existing mp4 file
    if os.path.isfile(output_name_abs):
        os.remove(output_name_abs)

    # Shell command split by the shlex utility
    arg = shlex.split('ffmpeg -qscale 5 -r 2 -b 9600 -i ' + input_names_abs +
                      ' ' + output_name_abs)

    # The shell command run
    rm.run_script(pics_dir, arg, wait=1, errout=1)


###############################################################################
#                       Sort indices according to endres                      #
###############################################################################
def indsort(
        which_methods,
        model_name='wavebc',
        which_res='endres',
        stat_method='mean',
        ensemble_sizes=[50, 70, 100, 250],
        ensemble_size=50,
        is_update=True,
):
    """
    Sort the methods specified in which_methods according to an array of
    statistical measures.

    Parameters
    ----------
    which_methods : array int
        Array of integers containing the method specifiers
        from module plotarrays.

    model_name : string
        'wavebc' - Model wavebc
        'wavereal' - Model wavereal
        'wavewell' - Model wavewell
        'wave' - Model wave

    which_res : string
        'endres' - use residuals after EnKF run
        'begres' - use residuals before EnKF run

    stat_method : string
        'mean' - Calculate means
        'std' - Standard deviation
        'stdm' - Standard deviation of the mean
        'median' - Median or 50 Percentile
        'q25' - 25 Percentile
        'q75' - 75 Percentile

    ensemble_sizes : array of integers
        array can typically contain 50, 70, 100, 250,
        500, 1000, 2000

    ensemble_size : integer
        Possibilities: 50, 70, 100, 250, 500, 1000, 2000.
        The ensemble size used for sorting

    is_update : boolean
        If True, the endres_mean array will be update.
        If False, an existing array would be used. Should
        be False if the underlying data is not present.

    Returns
    -------
    which_methods_sorted : array of ints
        Array sorted indices.

    Notes
    -------
    The array containing the statistical measures is loaded according to the
    input of the function. The array should be found in output/errorplot/npy.
    If it is not found, it should be generated using the read-function in
    'pskf.scripts.errorplot.read'.
    """

    # Name of the array for sorting
    array_name = pm.py_output_filename(
        'errorplot', which_res,
        stat_method + '_' + model_name + '_' + '_'.join([
            str(enssize) for enssize in ensemble_sizes
        ]) + '_' + '_'.join([str(i) for i in which_methods]), 'npy')

    # Ensure array existence or update
    if is_update or not os.path.isfile(array_name):
        numpy_array, numpy_array_name = er.read(
            which_methods=which_methods,
            ensemble_sizes=ensemble_sizes,
            model=model_name,
            which_res=which_res,
            stat_method=stat_method,
        )
        np.save(numpy_array_name, numpy_array)

    # Index of ensemble size
    iensemble_size = pa.indens[model_name][ensemble_size]

    # Load array
    array = np.load(array_name)[:, iensemble_size]

    # Indices for sorting order
    which_methods_sorted = np.argsort(array)

    return which_methods_sorted


###############################################################################
#                                 my_hdf                                      #
###############################################################################
def my_hdf(fdir, fname, varname):
    """
    Get hdf-dataset from filename and varname

    Parameters
    ----------
    fdir : string
        Path to the file. Without '/' at end.

    fname : string
        Name of the file.

    varname: string
        Name of the variable

    Returns
    ----------
    hdf_reader : vtk Reader instance
        hdf-dataset containing array information.
    """

    # Check existence of file.
    if not os.path.isfile(fdir + '/' + fname):
        raise exceptions.RuntimeError(fname + ' not in ' + fdir)

    # Read file
    hdf_f = h5py.File(fdir + '/' + fname)

    # Check if varname is in file
    if varname not in hdf_f.keys():
        raise exceptions.RuntimeError(varname + ' not in ' + fname +
                                      '\n Dir: ' + fdir)

    # Dataset
    hdf_array = hdf_f[varname]

    # Numpy array
    hdf_numpy = np.array(hdf_array)

    # Reshape
    hdf_numpy = np.transpose(hdf_numpy, [2, 1, 0])

    # Close file
    hdf_f.close()

    return hdf_numpy
