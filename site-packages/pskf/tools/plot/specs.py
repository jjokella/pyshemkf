"""
specs
=====

Functions generating specifiers for output naming conventions.

Functions reading model specifications from SHEMAT-Suite output.
"""
import os
import exceptions
import numpy as np
from pskf.tools.run import pythonmodule as pm
from pskf.tools.run import runmodule as rm


###############################################################################
#                                     specl                                   #
###############################################################################
def specl(model_name, dat, let):
    """
    Specifier-string consisting of
    - INPUT model name
    - INPUT date
    - INPUT letter (specified as string, otherwi)
    - two '_' in between
    """
    return model_name + '_' + dat + '_' + let


###############################################################################
#                                    nrens                                    #
###############################################################################
def nrens(model_name, dat, let):
    """
    Number of ensemble members for model_name
    """
    output_path = rm.make_output_dirs(model_name, dat, let)[0]
    input_file = rm.make_file_dir_names(model_name)[2]

    line = rm.read_hashtag_input(output_path+'/'+input_file, '# simulate', 1)
    first_entry = str.split(line)[0]
    nrens = int(first_entry)

    return nrens


###############################################################################
#                                   num_mons                                  #
###############################################################################
def num_mons(model_name, dat, let):
    """
    Number of monitoring points for model_name.
    """
    output_path = rm.make_output_dirs(model_name, dat, let)[0]
    true_input_file = rm.make_file_dir_names(model_name)[4]

    num_mons = rm.read_records_input(output_path+'/'+true_input_file,
                                     '# monitor,')

    return num_mons


###############################################################################
#                                   num_single_cell                           #
###############################################################################
def num_single_cell(model_name, dat, let):
    """
    Number of single cell observation points for model_name.

    Remark: We use the comma in the hashtag-search in order to exclude
    '# single cell output times' from the read_records_input search.
    """
    output_path = rm.make_output_dirs(model_name, dat, let)[0]
    enkf_input_file = rm.make_file_dir_names(model_name)[3]

    num_single_cell = rm.read_records_input(output_path+'/'+enkf_input_file,
                                            '# single cell output,')

    return num_single_cell


###############################################################################
#                                  nrobs_int                                  #
###############################################################################
def nrobs_int(model_name, dat, let):
    """
    Number of observation intervals for model_name.
    """
    output_path = rm.make_output_dirs(model_name, dat, let)[0]
    enkf_input_file = rm.make_file_dir_names(model_name)[3]

    line = rm.read_hashtag_input(output_path+'/'+enkf_input_file,
                                 '# nrobs_int', 1)
    first_entry = str.split(line)[0]
    nrobs_int = int(first_entry)
    return nrobs_int


###############################################################################
#                             monitor_locs                                    #
###############################################################################
def monitor_locs(model_name, dat, let):
    """
    Monitor point locations of model_name.
    """
    output_path = rm.make_output_dirs(model_name, dat, let)[0]
    true_input_file = rm.make_file_dir_names(model_name)[4]
    n_mons = num_mons(model_name, dat, let)

    lines = rm.read_hashtag_input(output_path+'/'+true_input_file,
                                  '# monitor',
                                  n_mons)
    locs = [[int(str.split(lines)[j]) for j in range(i, i+3)]
            for i in range(0, 4*n_mons, 4)]

    return locs


###############################################################################
#                             single_cell_locs                                #
###############################################################################
def single_cell_locs(model_name, dat, let):
    """
    Single cell locations of model_name, dat and lets
    """
    output_path = rm.make_output_dirs(model_name, dat, let)[0]
    enkf_input_file = rm.make_file_dir_names(model_name)[3]
    n_sc = num_single_cell(model_name, dat, let)

    lines = rm.read_hashtag_input(output_path+'/'+enkf_input_file,
                                  '# single cell output, ', n_sc)

    locs = [[int(str.split(lines)[j]) for j in range(i, i+3)]
            for i in range(0, 5*n_sc, 5)]

    return locs


###############################################################################
#                                   variable                                  #
###############################################################################
def single_cell_variables(model_name, dat, let):
    """
    Single cell variable of model_name.

     1: head,  2:temp,  3:conc,  4:kz,  5:lz,  6:por  (inside mem)
    11: head, 12:temp, 13:conc, 14:kz, 15:lz, 16:por  (not inside mem)
    """
    output_path = rm.make_output_dirs(model_name, dat, let)[0]
    enkf_input_file = rm.make_file_dir_names(model_name)[3]
    n_sc = num_single_cell(model_name, dat, let)

    lines = rm.read_hashtag_input(output_path+'/'+enkf_input_file,
                                  '# single cell output, ', n_sc)
    variables = [int(str.split(lines)[i]) for i in range(3, 5*n_sc, 5)]

    return variables


###############################################################################
#                                 num_pres_vel                                #
###############################################################################
def num_pres_vel(model_name, dat, let):
    """
    Number of velocity components for model_name.
    """
    output_path = rm.make_output_dirs(model_name, dat, let)[0]
    enkf_input_file = rm.make_file_dir_names(model_name)[3]

    num_pres_vel = rm.read_records_input(output_path+'/'+enkf_input_file,
                                         '# prescribed velocity')

    return num_pres_vel


###############################################################################
#                                      ns                                     #
###############################################################################
def ns(model_name, dat, let):
    """
    First observation time for model_name.
    """
    output_path = rm.make_output_dirs(model_name, dat, let)[0]
    obs_file = rm.make_file_dir_names(model_name)[13]

    file_input = open(output_path+'/'+obs_file, 'r')
    file_input.readline()
    ns = int(str.split(file_input.readline())[0])

    # Python starts at 0
    ns = ns-1

    return ns


###############################################################################
#                                      nm                                     #
###############################################################################
def nm(model_name, dat, let):
    """
    Difference of observation times for model_name.
    """
    output_path = rm.make_output_dirs(model_name, dat, let)[0]
    obs_file = rm.make_file_dir_names(model_name)[13]

    n_mons = num_mons(model_name, dat, let)

    file_input = open(output_path+'/'+obs_file, 'r')
    file_input.readline()
    ns1 = int(str.split(file_input.readline())[0])
    for i in range(n_mons):
        file_input.readline()
    ns2 = int(str.split(file_input.readline())[0])
    nm = ns2-ns1

    return nm


###############################################################################
#                                    units                                    #
###############################################################################
def units(model_name, dat, let, uindex, pindex):
    """
    Read parameters pindex from unit uindex
    pindex:
    1 - Porosity
    4 - Permeability
    8 - Thermal conductivity
    10 - Volumetric heat capacity
    """

    # Define path and file
    output_path = rm.make_output_dirs(model_name, dat, let)[0]
    input_file = rm.make_file_dir_names(model_name)[2]

    # Read hashtag input
    lines = rm.read_hashtag_input(output_path+'/'+input_file,
                                  '# units', uindex)

    # Split hashtag input by white space
    split_lines = str.split(lines)

    # Find the number of parameters per line
    num_ps = len(split_lines)/uindex
    # Calculate the index of the right parameter
    right_index = (uindex-1)*num_ps + pindex

    right_entry = split_lines[right_index]

    return right_entry


###############################################################################
#                             Number of time steps                            #
###############################################################################
def nt(model_name, dat, let):
    """
    Read the number of time steps (used in observation file)
    """

    # Define path and file
    output_path = rm.make_output_dirs(model_name, dat, let)[0]
    input_file = rm.make_file_dir_names(model_name)[2]

    # Read records (number lines in time step input)
    num_time_records = rm.read_records_input(output_path+'/'+input_file,
                                             '# time periods')

    # Read hashtag input
    lines = rm.read_hashtag_input(output_path+'/'+input_file,
                                  '# time periods', num_time_records)

    # Split hashtag input by white space
    split_lines = str.split(lines)

    # Read entry 3/4 in each line
    right_entries = split_lines[2::4]

    # Sum of the entries
    # -> Adding one accounts for the first time step at time = 0
    nt = sum([int(right_entries[i]) for i in range(len(right_entries))]) + 1

    return nt


###############################################################################
#                             Observation times                               #
###############################################################################
def obstimes(model_name, dat, let):
    """
    Read the observation times from the observations file.

    Remark
    ----------
        nskip is the number of observations per observation time.
        This method only works, when this number is constant over
        all observation times.
    """

    # Define path and file
    output_path = rm.make_output_dirs(model_name, dat, let)[0]
    observations_file = rm.make_file_dir_names(model_name)[13]

    # Read number of observations per observation time
    nskip = np.loadtxt(output_path+'/'+observations_file,
                       skiprows=1,
                       usecols=[2])[0]

    # Read time data from observations file
    obstimes = np.loadtxt(output_path+'/'+observations_file,
                          skiprows=1,
                          usecols=[1])[::nskip+1]

    # Take only the first nrobs_int entries
    obstimes = obstimes[:nrobs_int(model_name, dat, let)]

    return obstimes


###############################################################################
#                                      x                                      #
###############################################################################
def x(model_name, dat, let):
    """
    Read model name and return the corresponding
    array of x-coordinates of cell centers.
    """
    delxarr = delx(model_name, dat, let)
    arr = np.array([np.sum(delxarr[:i])+0.5*delxarr[i]
                    for i in range(delxarr.size)])
    return arr


###############################################################################
#                                      y                                      #
###############################################################################
def y(model_name, dat, let):
    """
    Read model name and return the corresponding
    array of y-coordinates of cell centers.
    """
    delyarr = dely(model_name, dat, let)
    arr = np.array([np.sum(delyarr[:i])+0.5*delyarr[i]
                    for i in range(delyarr.size)])
    return arr


###############################################################################
#                                      z                                      #
###############################################################################
def z(model_name, dat, let):
    """
    Read model name and return the corresponding
    array of z-coordinates of cell centers.
    """
    delzarr = delz(model_name, dat, let)
    arr = np.array([np.sum(delzarr[:i])+0.5*delzarr[i]
                    for i in range(delzarr.size)])
    return arr


###############################################################################
#                                    xlims                                    #
###############################################################################
def xlims(model_name, dat, let):
    """
    Read model name and return the corresponding
    limits of x-coordinates.
    """
    delxarr = delx(model_name, dat, let)
    xarr = x(model_name, dat, let)
    xlims = np.array([xarr[0] - 0.5*delxarr[0],
                      xarr[-1] + 0.5*delxarr[-1]])

    return xlims


###############################################################################
#                                    ylims                                    #
###############################################################################
def ylims(model_name, dat, let):
    """
    Read model name and return the corresponding
    limits of y-coordinates.
    """
    delyarr = dely(model_name, dat, let)
    yarr = y(model_name, dat, let)
    ylims = np.array([yarr[0] - 0.5*delyarr[0],
                      yarr[-1] + 0.5*delyarr[-1]])

    return ylims


###############################################################################
#                                    zlims                                    #
###############################################################################
def zlims(model_name, dat, let):
    """
    Read model name and return the corresponding
    limits of z-coordinates.
    """
    delzarr = delz(model_name, dat, let)
    zarr = z(model_name, dat, let)
    zlims = np.array([zarr[0] - 0.5*delzarr[0],
                      zarr[-1] + 0.5*delzarr[-1]])

    return zlims


###############################################################################
#                                    xticks                                   #
###############################################################################
def xticks(model_name, dat, let):
    """
    Read model name and return the corresponding
    array of x-coordinates of left side of cells.
    """
    delxarr = delx(model_name, dat, let)
    arr = np.array([np.sum(delxarr[:i]) for i in range(delxarr.size+1)])
    return arr


###############################################################################
#                                    yticks                                   #
###############################################################################
def yticks(model_name, dat, let):
    """
    Read model name and return the corresponding
    array of y-coordinates of front side of cells.
    """
    delyarr = dely(model_name, dat, let)
    arr = np.array([np.sum(delyarr[:i]) for i in range(delyarr.size+1)])
    return arr


###############################################################################
#                                    zticks                                   #
###############################################################################
def zticks(model_name, dat, let):
    """
    Read model name and return the corresponding
    array of z-coordinates of front side of cells.
    """
    delzarr = delz(model_name, dat, let)
    arr = np.array([np.sum(delzarr[:i]) for i in range(delzarr.size+1)])
    return arr


###############################################################################
#                                     delx                                    #
###############################################################################
def delx(model_name, dat, let):
    """
    Read model name, output date and letter and
    return the corresponding array of cell lengths
    in x-direction.
    """
    output_dir = rm.make_output_dirs(model_name, dat, let)[0]
    input_file = rm.make_file_dir_names(model_name)[2]

    arr_filename = pm.py_output_filename(
        'specs',
        'delx',
        specl(model_name, dat, let),
        'npy'
    )

    if rm.check_hashtag(output_dir, input_file, "# delx"):
        line = rm.read_hashtag_input(output_dir+'/'+input_file,
                                     '# delx', 1)
    else:
        input_file = rm.make_file_dir_names(model_name)[4]
        if rm.check_hashtag(output_dir, input_file, "# delx"):
            line = rm.read_hashtag_input(output_dir+'/'+input_file,
                                         '# delx', 1)
        else:
            if os.path.isfile(arr_filename):
                return np.load(arr_filename)
            else:
                raise exceptions.IOError('Input files, hashtags or'
                                         + ' npy file not found:\n\n'
                                         + output_dir + '\n\n'
                                         + input_file + '\n\n'
                                         + arr_filename)

    num_entries = len(str.split(line))
    nums = [int(str.split(entry, "*")[0])
            if len(str.split(entry, "*")) > 1 else
            1
            for entry in str.split(line)]
    lens = [float(str.split(entry, "*")[1])
            if len(str.split(entry, "*")) > 1 else
            float(str.split(entry, "*")[0])
            for entry in str.split(line)]

    vec = [[lens[i] for j in range(nums[i])] for i in range(num_entries)]

    arr = np.array([num for elem in vec for num in elem])

    np.save(arr_filename, arr)

    return arr


###############################################################################
#                                     dely                                    #
###############################################################################
def dely(model_name, dat, let):
    """
    Read model name, output date and letter and
    return the corresponding array of cell lengths
    in y-direction.
    """
    output_dir = rm.make_output_dirs(model_name, dat, let)[0]
    input_file = rm.make_file_dir_names(model_name)[2]

    arr_filename = pm.py_output_filename(
        'specs',
        'dely',
        specl(model_name, dat, let),
        'npy'
    )

    if rm.check_hashtag(output_dir, input_file, "# dely"):
        line = rm.read_hashtag_input(output_dir+'/'+input_file,
                                     '# dely', 1)
    else:
        input_file = rm.make_file_dir_names(model_name)[4]
        if rm.check_hashtag(output_dir, input_file, "# dely"):
            line = rm.read_hashtag_input(output_dir+'/'+input_file,
                                         '# dely', 1)
        else:
            if os.path.isfile(arr_filename):
                return np.load(arr_filename)
            else:
                raise exceptions.IOError('Input files, hashtags or'
                                         + ' npy file not found:\n\n'
                                         + output_dir + '\n\n'
                                         + input_file + '\n\n'
                                         + arr_filename)

    num_entries = len(str.split(line))
    nums = [int(str.split(entry, "*")[0])
            if len(str.split(entry, "*")) > 1 else
            1
            for entry in str.split(line)]
    lens = [float(str.split(entry, "*")[1])
            if len(str.split(entry, "*")) > 1 else
            float(str.split(entry, "*")[0])
            for entry in str.split(line)]

    vec = [[lens[i] for j in range(nums[i])] for i in range(num_entries)]

    arr = np.array([num for elem in vec for num in elem])

    np.save(arr_filename, arr)

    return arr


###############################################################################
#                                     delz                                    #
###############################################################################
def delz(model_name, dat, let):
    """
    Read model name, output date and letter and
    return the corresponding array of cell lengths
    in z-direction.
    """
    output_dir = rm.make_output_dirs(model_name, dat, let)[0]
    input_file = rm.make_file_dir_names(model_name)[2]

    arr_filename = pm.py_output_filename(
        'specs',
        'delz',
        specl(model_name, dat, let),
        'npy'
    )

    if rm.check_hashtag(output_dir, input_file, "# delz"):
        line = rm.read_hashtag_input(output_dir+'/'+input_file,
                                     '# delz', 1)
    else:
        input_file = rm.make_file_dir_names(model_name)[4]
        if rm.check_hashtag(output_dir, input_file, "# delz"):
            line = rm.read_hashtag_input(output_dir+'/'+input_file,
                                         '# delz', 1)
        else:
            if os.path.isfile(arr_filename):
                return np.load(arr_filename)
            else:
                raise exceptions.IOError('Input files, hashtags or'
                                         + ' npy file not found:\n\n'
                                         + output_dir + '\n\n'
                                         + input_file + '\n\n'
                                         + arr_filename)

    num_entries = len(str.split(line))
    nums = [int(str.split(entry, "*")[0])
            if len(str.split(entry, "*")) > 1 else
            1
            for entry in str.split(line)]
    lens = [float(str.split(entry, "*")[1])
            if len(str.split(entry, "*")) > 1 else
            float(str.split(entry, "*")[0])
            for entry in str.split(line)]

    vec = [[lens[i] for j in range(nums[i])] for i in range(num_entries)]

    arr = np.array([num for elem in vec for num in elem])

    np.save(arr_filename, arr)

    return arr
