from matplotlib import colors
import numpy as np
import exceptions
import matplotlib.pyplot as plt

from mypackage.tools.run import pythonmodule as pm
from mypackage.tools.plot import plotarrays as pa

from mypackage.scripts.errorplot import arrays as ea


###############################################################################
#                          Errorplot RMSE point plot                          #
###############################################################################
def plot(
        ax,
        which_methods=[0, 1, 2, 3, 4, 5, 6],
        which_res='endres',
        stat_method='mean',
        ensemble_sizes=[50, 70, 100, 250],
        axistitle='',
        model='wavebc',
        is_std=False,
        lineyval=0.62,
        std_method='std',
        pic_format='pdf',
        figpos=[0.15, 0.3, 0.8, 0.6],
        xlim_min=0,
        xlim_max=None,
        ylims=[0.28, 0.82],
        is_textpos_auto=True,
        textpos=[0.7, 0.6, 0.5, 0.4],
        xdiff_nens=0.5,
        yticks=[0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1],
        num_pack=4,  # Number of methods in pack
        is_text=False,
        text_x=0.5,
        text_y=0.5,
        formatsos=['o', 'v', 's', 'p',
                   'o', 'v', 's', 'p',
                   'o', 'v', 's', 'p',
                   'o', 'v', 's', 'p',
                   'o', 'v', 's', 'p',
                   'o', 'v', 's', 'p',
                   'o', 'v', 's', 'p',
                   'o', 'v', 's', 'p'],
        coleros=[(0.0, 0.0, 0.0), (0.0, 0.0, 0.0),
                 (0.0, 0.0, 0.0), (0.0, 0.0, 0.0),
                 (1.0, 1.0, 1.0), (1.0, 1.0, 1.0),
                 (1.0, 1.0, 1.0), (1.0, 1.0, 1.0),
                 (0.0, 0.0, 0.0), (0.0, 0.0, 0.0),
                 (0.0, 0.0, 0.0), (0.0, 0.0, 0.0),
                 (1.0, 1.0, 1.0), (1.0, 1.0, 1.0),
                 (1.0, 1.0, 1.0), (1.0, 1.0, 1.0),
                 (0.0, 0.0, 0.0), (0.0, 0.0, 0.0),
                 (0.0, 0.0, 0.0), (0.0, 0.0, 0.0),
                 (1.0, 1.0, 1.0), (1.0, 1.0, 1.0),
                 (1.0, 1.0, 1.0), (1.0, 1.0, 1.0),
                 (0.0, 0.0, 0.0), (0.0, 0.0, 0.0),
                 (0.0, 0.0, 0.0), (0.0, 0.0, 0.0),
                 (1.0, 1.0, 1.0), (1.0, 1.0, 1.0),
                 (1.0, 1.0, 1.0), (1.0, 1.0, 1.0)],
        markersize=10,
        markeredgesize=1.5,
        fontleg=30,
        fonttit=40,
        fontlab=40,
        fonttic=30,
):
    """
    A plotting function for statistics of residual distributions.

    Parameters
    ----------
    ax : Axes
        The axes to draw to.

    which_methods : array int
        Array of integers containing the method specifiers
        from module plotarrays.
        The methods appear in the plot in this order.

    which_res : string
        'endres' - use residuals after EnKF run
        'begres' - use residuals before EnKF run

    stat_method : string
        'mean' - Means
        'std' - Standard deviation
        'stdm' - Standard deviation of the mean
        'median' - Median or 50 Percentile
        'q25' - 25 Percentile
        'q75' - 75 Percentile

    ensemble_sizes : array of integers
        array can typically contain 50, 70, 100, 250,
        500, 1000, 2000

    model : string
        'wavebc' - Model wavebc
        'wave' - Model wave

    is_std : boolean
        True - Show errorbars of standard deviation
        False - No errorbars

    std_method : string
        Standard deviation to use
        'std' - Standard deviation
        'stdm' - Standard deviation of mean

    pic_format : string
        Format of the picture
        'pdf' - pdf-format
        'eps' - eps-format
        'png' - png-format
        'jpg' - jpg-format
        'svg' - svg-format

    figpos : array of floats
        Four numbers
        xbeg, ybeg, xrange, yrange

    More input specifying plot parameters.

    Returns
    -------
    ax : Axes
        Axes containing plot.

    pic_name : string
        Containing proposed saving location for Figure.
    """

    # Check
    for enssize in ensemble_sizes:
        if enssize not in [50, 70, 100, 250, 500, 1000, 2000]:
            raise exceptions.RuntimeError(
                'Wrong ensemble size.'
                )

    # Title
    ax.set_title(axistitle, size=fonttit)

    # Number of methods
    num_methods = len(which_methods)

    # Legend input
    legend_input = pa.longnames_methods
    legend_input = np.array([legend_input[i].ljust(18) for i in which_methods])

    # Load residuals
    res = np.load(pm.py_output_filename(
        'errorplot',
        which_res,
        stat_method+'_'+model+'_'
        + '_'.join([str(enssize) for enssize in ensemble_sizes])+'_'
        + '_'.join([str(i) for i in which_methods]),
        'npy'
    ))

    # Load standard deviation
    if is_std:
        std = np.load(pm.py_output_filename(
            'errorplot',
            which_res,
            std_method+'_'+model+'_'
            + '_'.join([str(enssize) for enssize in ensemble_sizes])+'_'
            + '_'.join([str(i) for i in which_methods]),
            'npy'))

    ax.set_prop_cycle("color", ['k'])
    ax.set_position(figpos)

    for iens, enssize in enumerate(ensemble_sizes):
        # x positions, up to 15 methods
        x = np.delete(np.arange(0, 100),
                      np.arange(0, 100, num_pack+1))
        # Skip one after num_pack+1 entries for vertical line

        resplot = res[:, iens]
        if is_std:
            stdplot = std[:, iens]

        # Plot
        puntos = []                            # Contains plotted points
        ax.plot(x[:len(resplot)], resplot, 'k-', label=3)
        for iplot in range(num_methods):
            # Points
            punto, = ax.plot(
                x[iplot],
                resplot[iplot],
                formatsos[iplot],
                lw=2,
                ms=markersize,
                label=legend_input[iplot],
                c=coleros[iplot], mew=markeredgesize
            )
            puntos.append(punto)

            # Text
            if iplot == num_methods-1:
                ax.text(
                    x[iplot]+xdiff_nens,
                    resplot[iplot] if is_textpos_auto else textpos[iens],
                    r'$n_{e}$='+str(enssize),
                    verticalalignment='center',
                    horizontalalignment='left',
                    size=20,
                )

            # Error
            if is_std:
                ax.errorbar(
                    x[iplot],
                    resplot[iplot],
                    yerr=stdplot[iplot],
                    fmt=formatsos[iplot],
                    lw=2,
                    ms=markersize,
                    label='this',
                    mfc=coleros[iplot],
                    mew=markeredgesize,
                    mec='black'
                )

    # Legend
    num_inleg = num_pack    # Methods per legend (except last)
    num_legs = (num_methods/num_inleg
                + int(bool(np.mod(num_methods,
                                  num_inleg))))  # Number of legends
    num_inlastleg = (np.mod(num_methods, num_inleg)
                     if np.mod(num_methods, num_inleg) else
                     num_inleg)  # Methods in last legend
    leginds = [num_inleg-1+i*num_inleg
               if i < num_legs-1 else
               num_inleg-1+(i-1)*num_inleg+num_inlastleg
               for i in range(num_legs)]  # last method ind in each legend
    legranges = [num_inleg if i < num_legs-1 else num_inlastleg
                 for i in range(num_legs)]  # Methods in each legend

    for ileg in range(num_legs):
        xleg = figpos[0] + ileg*figpos[2]/num_legs
        my_legend = ax.legend(
            handles=[puntos[i]
                     for i in range(leginds[ileg]-legranges[ileg]+1,
                                    leginds[ileg]+1)],
            bbox_to_anchor=[xleg,
                            0.00,
                            figpos[2]/num_legs,
                            0.3],
            bbox_transform=plt.gcf().transFigure,
            # loc=[0.0, 1.0],
            mode='expand',
            # labelspacing=1.0,
            ncol=1,
            numpoints=1,
            fontsize=fontleg,
            framealpha=1.0,
            markerscale=1.0
        )
        ax.add_artist(my_legend)

    # Lines
    for xline in range(0, 100, num_pack+1):
        ax.vlines(xline, 0.0, 1.0, linestyles='dotted')

    for yline in yticks:
        ax.hlines(yline, 0, 100, linestyles='dotted')

    ax.hlines(lineyval, 0, 100, linestyles='dashed')

    # Text: Model name and n_syn in box
    if is_text:
        model_spec = '  Tracer  ' if model == 'wavereal' else '   Well   '
        ax.text(
            text_x, text_y,
            model_spec+'\n'
            + r' $n_{syn}$: '+str(1000).rjust(4),
            linespacing=1.5,
            fontsize=30,
            bbox={'facecolor': (0.8, 0.8, 0.8), 'alpha': 1.0, 'pad': 10},
        )

    # Style
    ax.set_xlim([xlim_min, (xlim_max if xlim_max else num_legs*(num_pack+1))])
    ax.set_ylabel(r'RMSE  $\log(K[m^2])$',
                  fontsize=fontlab,
                  labelpad=10)
    ax.tick_params(direction='in', length=6,
                   width=1, labelsize=fonttic,
                   top='off', right='off', bottom='off',
                   pad=8)
    ax.set_xticks([])
    ax.set_yticks(yticks)
    ax.get_xaxis().set_visible('off')
    ax.set_ylim(ylims)

    # Saving location
    pic_name = pm.py_output_filename(
        ea.tag,
        which_res,
        stat_method+'_'+model+'_'
        + '_'.join([str(enssize) for enssize in ensemble_sizes])+'_'
        + '_'.join([str(i) for i in which_methods]),
        pic_format
    )

    return ax, pic_name


###############################################################################
#                          Matrix plot of RMSE quotients                      #
###############################################################################
def quots(
        ax,
        which_methods=[0, 1, 2, 3, 4, 5, 6],
        which_res='endres',
        stat_method='mean',
        model='wavebc',
        ensemble_sizes=[50, 70, 100, 250],
        ensemble_size=50,
        pic_format='pdf',
        is_text=False,
        axistitle='',
        fonttit=40,
        figpos=[0.32, 0.2, 0.6, 0.8],
        ticksize=20,
):
    """
    A function plotting a grid of quotients of
    statistical measures.

    Parameters
    ----------
    ax : Axes
        The axes to draw to.

    which_methods : array int
        Array of integers containing the method specifiers
        from module plotarrays.
        The methods appear in the plot in this order.

    which_res : string
        'endres' - use residuals after EnKF run
        'begres' - use residuals before EnKF run

    stat_method : string
        'mean' - Means
        'std' - Standard deviation
        'stdm' - Standard deviation of the mean
        'median' - Median or 50 Percentile
        'q25' - 25 Percentile
        'q75' - 75 Percentile

    model : string
        'wavebc' - Model wavebc
        'wave' - Model wave

    ensemble_sizes : array of integers
        array can typically contain 50, 70, 100, 250,
        500, 1000, 2000

    ensemble_size : integer
        Ensemble size of the job. Possibilities: 50,
        70, 100, 250, 500, 1000, 2000

    pic_format : string
        Format of the picture
        'pdf' - pdf-format
        'eps' - eps-format
        'png' - png-format
        'jpg' - jpg-format
        'svg' - svg-format

    figpos : array of floats
        Four numbers
        xbeg, ybeg, xrange, yrange

    More input specifying plot parameters.

    Returns
    -------
    ax : Axes
        Axes containing quotient matrix.

    pic_name : string
        Containing proposed saving location for Figure.
    """

    # Check
    if ensemble_size not in [50, 70, 100, 250, 500, 1000, 2000]:
        raise exceptions.RuntimeError('ensemble_size wrong')

    # Title
    ax.set_title(axistitle, size=fonttit)

    # Number of compared methods
    num_methods = len(which_methods)

    # Ensemble size translated to index
    iens = pa.indens[model][ensemble_size]

    # Load residuals
    res = np.load(pm.py_output_filename(
        'errorplot',
        which_res,
        stat_method+'_'+model+'_'
        + '_'.join([str(enssize) for enssize in ensemble_sizes])+'_'
        + '_'.join([str(i) for i in which_methods]),
        'npy'))

    # Calculate and sort quots
    quots = np.array(
        [[res[i1, iens]/res[i2, iens] for i1 in range(num_methods)]
         for i2 in range(num_methods)]
        )

    ax.set_position(figpos)

    # White Rectangles
    for ipm in range(num_methods):
        for jpm in range(num_methods):
            # Diagonal black
            if ipm == jpm:
                quots[ipm, jpm] = 0.0
            # Upper triangle white
            if ipm < jpm:
                quots[ipm, jpm] = None

    ax.imshow(
        quots,
        interpolation='nearest',
        cmap='Greys_r',
        norm=colors.Normalize(vmin=0.8, vmax=1.0, clip=False)
    )

    # Plot: Mostly ticks
    ax.set_xticks([i for i in range(num_methods)])
    ax.set_xticklabels([pa.names_methods[which_methods[i]]
                        for i in range(len(which_methods))],
                       fontsize=ticksize,
                       rotation=90)
    ax.set_yticks([i for i in range(num_methods)])
    ax.set_yticklabels([pa.names_methods[which_methods[i]]
                        for i in range(len(which_methods))],
                       fontsize=ticksize)
    ax.tick_params(length=0)
    ax.set_frame_on(False)

    # Text
    for itext in range(num_methods):
        for jtext in range(num_methods):
            if itext < jtext:
                ntext = quots[jtext, itext]
                ttext = str(ntext)[0:4]
                px = itext-0.35
                py = jtext+0.15
                colero = 'white' if ntext < 0.9 else 'black'

                ax.text(px, py, ttext, color=colero, fontsize=25)

    # Text: n_syn and ensemble_size
    if is_text:
        model_spec = '  Tracer  ' if model == 'wavereal' else '   Well   '
        ax.text(
            3.5, 1.5,
            model_spec+'\n'
            + r' $n_{e}$: '+str(ensemble_size).rjust(4),
            linespacing=1.5,
            fontsize=30,
            bbox={'facecolor': 'grey', 'alpha': 0.5, 'pad': 10},
        )

    # Saving location
    pic_name = pm.py_output_filename(
        ea.tag,
        'quots_'+which_res,
        stat_method+'_'+model+'_'
        + str(ensemble_size)+'_'
        + '_'.join([str(i) for i in which_methods]),
        pic_format)

    return ax, pic_name
