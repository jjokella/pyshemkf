import matplotlib as mpl
from matplotlib import colors
from matplotlib import pyplot as plt

import numpy as np
import exceptions

from mypackage.tools.run import pythonmodule as pm
from mypackage.tools.plot import plotarrays as pa

from mypackage.scripts.numcomp import arrays as na


###############################################################################
#             Plot bars of probabilites for numerical comparisons             #
###############################################################################
def plot(
        ax,
        which_methods,
        which_methods_left,
        which_methods_right,
        which_res='endres',
        model='wavebc',
        method='ttest',
        ensemble_size=50,
        n_syn=1,
        n_syn_bold=1,
        n_comparisons=10000,
        pic_format='pdf',
        bar_colors=['black', 'white', 'grey']
):

    """
    Reads probability arrays which method is better,
    worse, or if they are even. Then plots those
    three possibilities in bars comparing the methods
    given in which_methods_left and which_methods_right.

    Parameters
    ----------
    ax : Axes
        The axes to draw to.

    which_methods : array int
        Array of integers containing the method specifiers
        from module plotarrays.

    which_methods_left : array int
        Array of integers containing the method specifiers
        for the left side of the comparisons.

    which_methods_right : array int
        Array of integers containing the method specifiers
        for the right side of the comparisons.

    which_res : string
        'endres' - use residuals after EnKF run
        'begres' - use residuals before EnKF run

    model : string
        'wavebc' - Model wavebc
        'wave' - Model wave

    method : string
        Which method to use for statistical comparison
        of the subset. If n_syn == 1, the comparison
        always defaults to comparing the residuals.
        'ttest' - Use the T-Test, testing if the
                  two samples belong to the same
                  Gaussian distribution.
        'gauss' - Calculate Gaussian distribution
                  of the difference and calculate
                  its probability to be larger
                  than zero.
        'meanc' - Calculate the means and compare.

    ensemble_size : integer
        Ensemble size of the job. Possibilities: 50,
        70, 100, 250, 500, 1000, 2000

    n_syn : integer
        Number of synthetic studies in subset.

    n_syn_bold : integer
        Number of synthetic studies in subset used for
        the bold ticklabels.

    n_comparisons : integer
        Number of comparisons calculated.

    pic_format : string
        Format of the picture
        'pdf' - pdf-format
        'eps' - eps-format
        'png' - png-format
        'jpg' - jpg-format
        'svg' - svg-format

    bar_colors : array of strings
        Three colors for the three patches of one bar.

    Returns
    -------
    ax : array
        Axes containing plot.

    pic_name : string
        Containing proposed saving location for Figure.
    """

    # Check
    for imethod in which_methods_left:
        if imethod not in which_methods:
            raise exceptions.RuntimeError(
                'Wrong methods in wrong_methods_left'
                )
    for imethod in which_methods_left:
        if imethod not in which_methods:
            raise exceptions.RuntimeError(
                'Wrong methods in wrong_methods_right'
                )

    if ensemble_size in [50, 70, 100, 250]:
        if n_syn > 1000:
            raise exceptions.RuntimeError('n_syn wrong')
    elif ensemble_size in [500, 1000, 2000]:
        if n_syn > 100:
            raise exceptions.RuntimeError('n_syn wrong')
    else:
        raise exceptions.RuntimeError('ensemble size wrong')

    # Both methods in one array
    show_methods = [which_methods_left,
                    which_methods_right]
    # Number of bars and patches
    num_bars = len(show_methods[0])
    num_patches = 3*num_bars

    # Load probs
    probs = np.load(
        pm.py_output_filename(
            na.tag,
            'probs_'+which_res, model
            + '_'+method+'_'+str(ensemble_size)+'_'+str(n_syn)+'_'
            + str(n_comparisons)+'_'
            + '_'.join([str(i) for i in which_methods]),
            'npy'
        )
    )

    # Load probs for bold labels
    probs_bold = np.load(
        pm.py_output_filename(
            na.tagn,
            'probs_'+which_res,
            model+'_'
            + method+'_'+str(ensemble_size)+'_'+str(n_syn_bold)
            + '_'+str(n_comparisons)+'_'
            + '_'.join([str(i) for i in which_methods]),
            'npy'
        )
    )

    ax.set_position([0.3, 0.05, 0.4, 0.75])
    ax.set_frame_on(False)

    # Patch arrays for ax.barh()
    in_bottom = np.zeros(num_patches)
    in_height = np.zeros(num_patches)
    in_width = np.zeros(num_patches)
    in_left = np.zeros(num_patches)
    in_color = ['' for i in range(num_patches)]
    for i in range(num_patches):
        in_bottom[i] = num_bars-i/3
        in_height[i] = 0.8
        in_width[i] = probs[show_methods[0][i/3],
                            show_methods[1][i/3]][np.mod(i, 3)]
        in_left[i] = np.sum(probs[show_methods[0][i/3],
                                  show_methods[1][i/3]][0:np.mod(i, 3)])
        in_color[i] = bar_colors[np.mod(i, 3)]

    # Plot patches in bars
    ax.barh(bottom=in_bottom,
            height=in_height,
            width=in_width,
            left=in_left,
            color=in_color,
            edgecolor='k')

    # H_0 labels inside bar
    if method == "ttest":
        for i in range(1, num_bars+1):
            if in_left[3*i-1]-in_left[3*i-2] > 0.15:
                ax.text(in_left[3*i-2]+0.4*(in_left[3*i-1]-in_left[3*i-2]),
                        in_bottom[3*i-2]+0.3,
                        "$H_0$",
                        fontsize=20)

    # Axis 1
    ax.tick_params(direction='out', length=0,
                   width=1, labelsize=20,
                   top='off', bottom='off',
                   labelright='off',
                   pad=8)
    ax.set_xlim([-0.01, 1.01])
    ax.set_ylim([0.9, num_bars+0.8])
    ax.set_xticks([])
    ax.set_yticks([num_bars-i+0.4 for i in range(num_bars)])
    ax.set_yticklabels(
        [pa.longnames_methods[show_methods[0][i]] for i in range(num_bars)]
        )

    # Twin Axis 2
    ax2 = ax.twinx()
    ax2.set_position([0.3, 0.05, 0.4, 0.75])
    ax2.set_frame_on(False)
    ax2.tick_params(direction='out', length=0,
                    width=1, labelsize=20,
                    top='off', bottom='off',
                    labelleft='off', labelright='on',
                    labelcolor='black',
                    pad=8)
    ax2.set_xlim([-0.01, 1.01])
    ax2.set_ylim([0.9, num_bars+0.8])
    ax2.set_xticks([])
    ax2.set_yticks([num_bars-i+0.4 for i in range(num_bars)])
    ax2.set_yticklabels(
        [pa.longnames_methods[show_methods[1][i]] for i in range(num_bars)]
        )

    # Boldness of axislabels
    for i in range(num_bars):
        if(probs_bold[show_methods[0][i], show_methods[1][i]][0] == 1):
            ax.yaxis.get_majorticklabels()[i].set_weight('bold')
        elif(probs_bold[show_methods[0][i], show_methods[1][i]][2] == 1):
            ax2.yaxis.get_majorticklabels()[i].set_weight('bold')
        else:
            ax.yaxis.get_majorticklabels()[i].set_style('italic')
            ax2.yaxis.get_majorticklabels()[i].set_style('italic')

    # Saving location
    pic_name = pm.py_output_filename(
        na.tag,
        'bars_'+which_res,
        model+'_'+method+'_'+str(ensemble_size)
        + '_'+str(n_syn)+str(n_comparisons)+'_'+'_'
        + '_'.join([str(i) for i in which_methods]),
        pic_format
        )

    return ax, pic_name


###############################################################################
#           Plot matrix of probabilties for a numerical comparisons           #
###############################################################################
def matrix(
        ax,
        which_methods=[0, 1, 2, 3, 4, 5, 6],
        indsorts=[1, 6, 5, 4, 3, 2, 0],
        which_res='endres',
        method='ttest',
        model='wavebc',
        ensemble_size=50,
        n_syn=1,  # number of synthetic studies
        n_comparisons=10000,
        pic_format='pdf',  # 'png' or 'eps' or 'svg' or 'pdf'
        figpos=[0.14, 0.14, 0.8, 0.8],  # xbeg, ybeg, xrange, yrange
        # ylims=[0.28,0.82],
        is_longnames=True,
        ticklabelfontsize=10,
        xtick_y=0.0,
        # num_pack=4,                     # Number of methods in pack
        # formatsos=['o','v','s','p','o','v','s','p'],
        # coleros=[(0.0,0.0,0.0),(0.0,0.0,0.0),(0.0,0.0,0.0),(0.0,0.0,0.0),
        #                (1.0,1.0,1.0),(1.0,1.0,1.0),(1.0,1.0,1.0),(1.0,1.0,1.0)],
        # markersize=10,
        # markeredgesize=1.5,
        # fontleg=30,                              #18
        # fonttit=40,
        # fontlab=40,
        # fonttic=30,
):
    """
    A plotting function for statistics of residual distributions.

    Parameters
    ----------
    ax : Axes
        The axes to draw to.

    which_methods : array of ints
        The methods to be loaded in ascending order.

    indsorts : array of ints
        The methods to included in own this order.

    which_res : string
        'endres' - use residuals after EnKF run
        'begres' - use residuals before EnKF run

    method : string
        Which method to use for statistical comparison
        of the subset. If n_syn == 1, the comparison
        always defaults to comparing the residuals.
        'ttest' - Use the T-Test, testing if the
                  two samples belong to the same
                  Gaussian distribution.
        'gauss' - Calculate Gaussian distribution
                  of the difference and calculate
                  its probability to be larger
                  than zero.
        'meanc' - Calculate the means and compare.

    model : string
        'wavebc' - Model wavebc
        'wave' - Model wave

    ensemble_size : integer
        Ensemble size of the job. Possibilities: 50,
        70, 100, 250, 500, 1000, 2000

    n_syn : integer
        Number of synthetic studies in subset.

    n_comparisons : integer
        Number of comparisons calculated.

    pic_format : string
        Format of the picture
        'pdf' - pdf-format
        'eps' - eps-format
        'png' - png-format
        'jpg' - jpg-format
        'svg' - svg-format

    Returns
    -------
    ax : Axes
        Axes containing plot.

    pic_name : string
        Containing proposed saving location for Figure.
    """

    # Check
    for imethod in indsorts:
        if imethod not in which_methods:
            raise exceptions.RuntimeError('Wrong methods in indsorts')

    if ensemble_size in [50, 70, 100, 250]:
        if n_syn > 1000:
            raise exceptions.RuntimeError('n_syn wrong')
    elif ensemble_size in [500, 1000, 2000]:
        if n_syn > 100:
            raise exceptions.RuntimeError('n_syn wrong')
    else:
        raise exceptions.RuntimeError('ensemble size wrong')

    # Number of compared methods
    num_methods = len(indsorts)

    # Load probs
    probs = np.load(pm.py_output_filename(
        na.tag,
        'probs_'+which_res,
        model+'_'+method+'_'+str(ensemble_size)
        + '_'+str(n_syn)+'_'+str(n_comparisons)+'_'
        + '_'.join([str(i) for i in which_methods]),
        'npy'
        ))

    # Indsorts: From model index to probs index
    which_methods = np.array(which_methods)
    indsorts = [np.where(which_methods == imod)[0][0] for imod in indsorts]

    # Sort probs
    probs = probs[indsorts, :, :]
    probs = probs[:, indsorts, :]

    ax.set_position(figpos)

    # Rectangles in upper right half: Fraction of Undecided
    undecided = probs[:, :, 1]
    for ipm in range(num_methods):
        for jpm in range(num_methods):
            if ipm > jpm:
                # Lower left half white
                undecided[ipm, jpm] = None
            if ipm == jpm:
                # Diagonal black
                undecided[ipm, jpm] = 1.0
            if ipm < jpm:
                # Single comparisons white
                if n_syn == 1:
                    undecided[ipm, jpm] = None
                # One comparison white
                if n_syn == 1000:
                    undecided[ipm, jpm] = None
                # For mean comparison white
                if method == 'meanc':
                    undecided[ipm, jpm] = None

    ax.imshow(undecided, interpolation='nearest', cmap='Greys',
              norm=colors.Normalize(vmin=0, vmax=1, clip=False))

    # Triangles: Grid
    X, Y = np.meshgrid(np.arange(num_methods+1), np.arange(num_methods+1))
    X = X.flatten()-0.5
    Y = Y.flatten()-0.5

    # Triangles: Indices
    triangles = np.zeros([2*np.sum(range(1, num_methods)), 3])

    ix = 0
    # Upper triangles
    for i in range(1, num_methods):
        for j in range(i, num_methods):
            triangles[ix, :] = [(i-1)+j*(num_methods+1),
                                i+j*(num_methods+1),
                                i+num_methods+j*(num_methods+1)]
            ix = ix+1
    # Lower triangles
    for i in range(1, num_methods):
        for j in range(i, num_methods):
            triangles[ix, :] = [i+j*(num_methods+1),
                                i+num_methods+j*(num_methods+1),
                                i+num_methods+1+j*(num_methods+1)]
            ix = ix+1

    # Triangles: Triangulation instance
    tria = mpl.tri.Triangulation(X, Y, triangles)

    # Triangles: Colors
    coleros = np.array([[probs[i, j, 0] for i in range(j+1, num_methods)]
                        for j in range(num_methods-1)]
                       + [[probs[i, j, 2] for i in range(j+1, num_methods)]
                          for j in range(num_methods-1)])
    coleros = np.hstack(coleros)

    # Triangles: Plot with facecolor
    plt.tripcolor(
        tria,
        facecolors=coleros,
        cmap=mpl.cm.Greys,
        norm=colors.Normalize(vmin=0, vmax=1, clip=False),
        edgecolor='k'
    )

    # Plot: Mostly ticks
    ticklabelinput = ([pa.longnames_methods[which_methods[indsorts][i]]
                       for i in range(num_methods)]
                      if is_longnames else
                      [pa.names_methods[which_methods[indsorts][i]]
                       for i in range(num_methods)])
    ax.set_xticks([i for i in range(num_methods)])
    ax.set_xticklabels(ticklabelinput, fontsize=ticklabelfontsize,
                       rotation=90, y=xtick_y)
    ax.set_yticks([i for i in range(num_methods)])
    ax.set_yticklabels(ticklabelinput, fontsize=ticklabelfontsize)
    ax.tick_params(length=0)
    ax.set_frame_on(False)

    # Text: Upper triangles
    for i in range(3):
        for itext in range(num_methods):
            for jtext in range(num_methods):
                if itext < jtext:
                    ntext = (100*probs[jtext, itext, i]
                             if i != 1 else
                             100*probs[itext, jtext, i])
                    ttext = str(ntext)[0:4] if ntext < 100 else str(ntext)[0:3]
                    px = (itext-0.35
                          if i == 0 else
                          (jtext-0.125 if i == 1 else itext-0.05))
                    py = (jtext-0.15
                          if i == 0 else
                          (itext+0.05 if i == 1 else jtext+0.3))
                    colero = 'white' if ntext > 50 else 'black'

                    if i != 1 or (n_syn != 1000
                                  and n_syn != 1
                                  and method != "meanc"):
                        ax.text(px, py, ttext, color=colero, fontsize=10)

    # Saving location
    pic_name = pm.py_output_filename(
        na.tag,
        'matrix_'+which_res,
        model+'_'+method+'_'+str(ensemble_size)
        + '_'+str(n_syn)+'_'+str(n_comparisons)+'_'
        + '_'.join([str(i) for i in which_methods]),
        pic_format
    )

    return ax, pic_name
