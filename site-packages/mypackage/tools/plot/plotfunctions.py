# Operating system commands
import os
import exceptions
import shlex

import numpy as np
import matplotlib as mpl
import matplotlib.cm as cm

import vtk
from vtk.util.numpy_support import vtk_to_numpy
from mypackage.tools.run import runmodule as rm
from mypackage.tools.run import pythonmodule as pm
from mypackage.tools.plot import plotarrays as pa
from mypackage.tools.plot import specs as sc
from mypackage.scripts.errorplot import read as er

import string

# Paths
python_dir = os.environ['HOME']+'/PythonDir'

alphabet = string.lowercase


###############################################################################
#                                 my_vtk                                      #
###############################################################################
def my_vtk(fdir, fname, varname):
    """
    Get vtk-reader from filename and varname

    Parameters
    ----------
    fdir : string
        Path to the file. Without '/' at end.

    fname : string
        Name of the file.

    varname: string
        Name of the variable

    Returns
    ----------
    vtk_reader: vtk Reader instance
        vtk Reader containing information about a vtk-file.
    """

    # Check if scalar variable is in vtk-file
    is_var_in_file(fdir, fname, varname)

    # Prepare vtk-Reader
    vtk_reader = vtk.vtkRectilinearGridReader()  # Reader
    vtk_reader.SetFileName(fdir+'/'+fname)    # Filename
    vtk_reader.SetScalarsName(varname)        # Variable name
    vtk_reader.Update()                       # Refresh

    return vtk_reader


def my_vtk_to_numpy(vtk_reader):
    """
    Read array from vtk_reader and output as numpy array.

    Parameters
    ----------
    vtk_reader: vtk Reader instance
        vtk Reader containing information about a vtk-file.

    Returns
    ----------
    numpy_array: Numpy array
        Numpy array containing the variable array corresponding to
        the vtk_reader.
    """

    vtk_output = vtk_reader.GetOutput()

    # Grid properties
    grid_dimens = vtk_output.GetDimensions()  # Grid Dimensions
    grid_bounds = vtk_output.GetBounds()      # Grid Bounds

    # Reshape array to grid geometry
    if grid_bounds[0] == 0.0:   # CELLS
        vtk_array = vtk_output.GetCellData().GetArray(0)
        # vtk_to_numpy and reshape
        numpy_array = vtk_to_numpy(vtk_array)
        numpy_array = numpy_array.reshape(
            grid_dimens[0]-1,
            1 if grid_dimens[1] == 1 else grid_dimens[1]-1
        )
    else:                       # POINTS
        vtk_array = vtk_output.GetPointData().GetArray(0)
        # vtk_to_numpy and reshape
        numpy_array = vtk_to_numpy(vtk_array)
        if vtk_reader.GetScalarsName() == 'v':
            numpy_array = numpy_array.reshape(grid_dimens[0], grid_dimens[1],
                                              3)
            numpy_array[:, :, 2] = np.sqrt(numpy_array[:, :, 0]**2
                                           + numpy_array[:, :, 1]**2)
        else:
            if grid_dimens[0] > 1 and grid_dimens[1] > 1:
                numpy_array = numpy_array.reshape(grid_dimens[0],
                                                  grid_dimens[1])
            elif grid_dimens[0] > 1 and grid_dimens[2] > 1:
                numpy_array = numpy_array.reshape(grid_dimens[0],
                                                  grid_dimens[2])
            else:
                raise exceptions.RuntimeError('Shape of array wrong: '
                                              + str(grid_dimens))

    return numpy_array


def my_vtk_grid_props(vtk_reader):
    """
    Get grid properties from vtk_reader instance.

    Parameters
    ----------
    vtk_reader: vtk Reader instance
        vtk Reader containing information about a vtk-file.

    Returns
    ----------
    step_x : float
        For regular grid, stepsize in x-direction.

    step_y : float
        For regular grid, stepsize in y-direction.

    npts_x : float
        Number of cells in x-direction.

    npts_y : float
        Number of cells in y-direction.

    low_m_x : float
        Middle of first x cell

    high_m_x : float
        Middle of last x cell

    low_m_y : float
        Middle of first y cell

    high_m_y : float
        Middle of last y cell

    low_x : float
        Edge of first x cell

    high_x : float
        Edge of last x cell

    low_y : float
        Edge of first y cell

    high_y : float
        Edge of last y cell

    Notes
    ----------
    0: step_x
    1: step_y
    2: npts_x
    3: npts_y
    4: low_m_x - Middle of cells: first x cell
    5: high_m_x - Middle of cells: last x cell
    6: low_m_y - Middle of cells: first y cell
    7: high_m_y - Middle of cells: last y cell
    8: low_x - Edge of cells: first x cell
    9: high_x - Edge of cells: last x cell
    10: low_y - Edge of cells: first y cell
    11: high_y - Edge of cells: last y cell
    """

    vtk_output = vtk_reader.GetOutput()

    # Read attributes of the vtk-Array
    # num_cells = vtk_output.GetNumberOfCells()
    # num_points = vtk_output.GetNumberOfPoints()
    # whole_extent = vtk_output.GetExtent()
    grid_bounds = vtk_output.GetBounds()
    grid_dims = vtk_output.GetDimensions()

    # Grid information
    step_x = (grid_bounds[1]-grid_bounds[0])/(grid_dims[0]-1)
    step_y = (grid_bounds[3]-grid_bounds[2])/(grid_dims[1]-1)
    if grid_bounds[0] == 0.0:     # CELLS
        npts_x = grid_dims[0]-1
        npts_y = grid_dims[1]-1
        low_m_x = grid_bounds[0] + 0.5*step_x
        high_m_x = grid_bounds[1] - 0.5*step_x
        low_m_y = grid_bounds[2] + 0.5*step_y
        high_m_y = grid_bounds[3] - 0.5*step_y
        low_x = grid_bounds[0]
        high_x = grid_bounds[1]
        low_y = grid_bounds[2]
        high_y = grid_bounds[3]
    else:                       # POINTS
        npts_x = grid_dims[0]
        npts_y = grid_dims[1]
        low_m_x = grid_bounds[0]
        high_m_x = grid_bounds[1]
        low_m_y = grid_bounds[2]
        high_m_y = grid_bounds[3]
        low_x = grid_bounds[0] - 0.5*step_x
        high_x = grid_bounds[1] + 0.5*step_x
        low_y = grid_bounds[2] - 0.5*step_y
        high_y = grid_bounds[3] + 0.5*step_y

    return step_x, step_y, \
        npts_x, npts_y, \
        low_m_x, high_m_x, low_m_y, high_m_y, \
        low_x, high_x, low_y, high_y


def my_vtk_make_quiver(vtk_reader, ax):
    """
    Read a field of arrows from vtk-file and insert it in axis.

    Parameters
    ----------
    vtk_reader: vtk Reader instance
        vtk Reader containing information about a vtk-file.

    ax : Axes
        The axes to draw to.

    Returns
    -------
    ax : array
        Axes containing plot.

    Notes
    -------
    Only regular grids supported!
    """
    # Quiver
    vtk_output = vtk_reader.GetOutput()

    # 1:Get Vector quantitiy
    v_vtk = vtk_output.GetPointData().GetArray(1)

    # Get grid properties
    (step_x, step_y, npts_x, npts_y, low_m_x,
     high_m_x, low_m_y, high_m_y) = my_vtk_grid_props(vtk_reader)[:8]

    # Generate regular grid, incl last cell
    x = np.arange(low_m_x, high_m_x+1, step_x)
    y = np.arange(low_m_y, high_m_y+1, step_y)
    X, Y = np.meshgrid(x, y)

    # vtk file to NumPy array
    v = vtk_to_numpy(v_vtk)

    # Vector components reshaped to grid
    vx = v[:, 0].reshape(npts_x, npts_y)
    vy = v[:, 1].reshape(npts_x, npts_y)

    # Arrows to axis
    ax.quiver(X, Y, vx, vy, scale=None)

    return ax


def is_var_in_file(path, fname, var, raise_io_error=1, raise_var_error=1,
                   only_scalar=0, only_vector=0):
    """
    Checks the existence of the file and whether var is a variable
    inside the file. Output: 1 if it is inside, 0 if it is not.
    By default, exceptions are raised if the variable is not inside
    the file.
    """
    # Check existence of file.
    try:
        f = open(path+'/'+fname, 'r')
    except IOError:
        if raise_io_error:
            print('\n' + path + '\n')
            raise
        else:
            return 0

    # Check if variable is SCALAR and in file.
    if not only_vector:
        for line in f:
            if line.find('SCALARS ' + var) > -1:
                f.close()
                return 1
            elif line.find('SCALARS  ' + var) > -1:
                f.close()
                return 1
            elif line.find('SCALARS   ' + var) > -1:
                f.close()
                return 1
            elif line.find('SCALARS    ' + var) > -1:
                f.close()
                return 1
    f.seek(0)
    # Check if variable is VECTOR and in file.
    if not only_scalar:
        for line in f:
            if line.find('VECTORS ' + var) > -1:
                f.close()
                return 1
            elif line.find('VECTORS  ' + var) > -1:
                f.close()
                return 1
            elif line.find('VECTORS   ' + var) > -1:
                f.close()
                return 1
            elif line.find('VECTORS    ' + var) > -1:
                f.close()
                return 1
    if raise_var_error:
        raise exceptions.RuntimeError(var + ' not in ' + fname
                                      + '\n Dir: ' + path)
    else:
        return 0


###############################################################################
#                                   cmap                                      #
###############################################################################
def cmap_discretize(cmap, N):
    """Return a discrete colormap from the continuous colormap cmap.

        cmap: colormap instance, eg. cm.jet.
        N: number of colors.

    Example
        x = resize(arange(100), (5,100))
        djet = cmap_discretize(cm.jet, 5)
        imshow(x, cmap=djet)
    """

    if type(cmap) == str:
        cmap = cm.get_cmap(cmap)
    colors_i = np.concatenate((np.linspace(0, 1., N), (0., 0., 0., 0.)))
    colors_rgba = cmap(colors_i)
    indices = np.linspace(0, 1., N+1)
    cdict = {}
    for ki, key in enumerate(('red', 'green', 'blue')):
        cdict[key] = [(indices[i], colors_rgba[i-1, ki], colors_rgba[i, ki])
                      for i in xrange(N+1)]
    # Return colormap object.
    return mpl.colors.LinearSegmentedColormap(cmap.name + "_%d" % N,
                                              cdict, 1024)


###############################################################################
#                                colorbar                                     #
###############################################################################
def cb(cb_ax,
       ax,
       varname="uindex",
       varlabels={
           'temp': r'Temperature [$^{\circ}\mathrm{C}$]',
           'head': r'$\mathrm{h}$ [$\mathrm{m}$] - $10\, \mathrm{m}$',
           'uindex': r'Unit Index',
           'kz': r'Permeability [$\log(\mathrm{m}^2)$])',
           'kz_mean': r'Permeability [$\log(\mathrm{m}^2)$]',
           'tracer1': r'Concentration [$\frac{\mathrm{mol}}{\mathrm{l}}$]',
           'lz': r'Thermal conductivity [$\log(\frac{W}{m\, K})$])',
       },
       cb_ax_position=[0.8, 0.1, 0.03, 0.8],
       labelsize=20):
    """
    Add colorbar to figure.

    Parameters
    ----------
    cb_ax : Axes
        Empty colorbar-Axes instance.

    ax : Axes
        The axes holding the colored image.

    Returns
    -------
    cb_ax : Axes
        Colobar-Axes instance including the colorbar.
    """

    im = ax.images[0]

    # colorbar
    cb_ax.set_position(cb_ax_position)
    cb_ax.tick_params(labelsize=labelsize)
    cb_ax.set_title(varlabels[varname], y=1.02, fontsize=40)
    mpl.colorbar.Colorbar(cb_ax, im)

    # Special uindex labels
    if varname == 'uindex':
        cb_ax.yaxis.set_ticklabels(["1: sand",
                                    "2: sand",
                                    "3: water",
                                    "4: water",
                                    "5: water",
                                    "6: water",
                                    "7: cement"])

    return cb_ax


###############################################################################
#                                 Scatter Plot                                #
###############################################################################
def scatter(
        ax,
        model_name,
        dat,
        let,
        is_ownlocs=False,
        ownlocs=[[1, 1, 1]],
        loc_inds=range(1),
        marker='o',
        markersize=50,
        markercolor='black',
        markeralpha=1.0,
):
    """
    Scatter plot of SHEMAT-Suite monitoring points.

    Parameters
    ----------
    ax : Axes
        The axes to draw to.

    model_name : string
        String of model name.
        'wavebc' - Model wavebc
        'wavereal' - Model wavereal
        'wavewell' - Model wavewell
        'wave' - Model wave

    dat : string
        String with date of model run.

    let : string
        String of letter of model run.

    Returns
    -------
    ax : Axes
        Axes containing scatter plots.

    Notes
    -------
    Could at some point be generalized to x-z arrays.
    """

    # Grid
    x = sc.x(model_name, dat, let)
    y = sc.y(model_name, dat, let)

    # Read
    if is_ownlocs:
        locs = np.array(ownlocs)
    else:
        locs = np.array(sc.locs(model_name, dat, let))

    # Scatterplot
    ax.scatter(x[locs[loc_inds][:, 0]-1],
               y[locs[loc_inds][:, 1]-1],
               marker=marker,
               c=markercolor,
               edgecolors=markercolor,
               alpha=markeralpha,
               s=markersize)

    return ax


###############################################################################
#                                   movie                                     #
###############################################################################
def movie(input_name_test='plot_m_b_01_100_av.png',
          input_names='plot_m_b_%02d_100_av.png',
          output_name='plot_m_b_100_av.mp4',
          pics_dir='None'):

    # Test for Directory
    if pics_dir == 'None':
        raise exceptions.RuntimeError('No directory specified')

    # Absolute path file names
    input_name_test_abs = pics_dir+'/'+input_name_test
    input_names_abs = pics_dir+'/'+input_names
    output_name_abs = pics_dir+'/'+output_name

    # Test for specific input file
    if not os.path.isfile(input_name_test_abs):
        raise exceptions.RuntimeError('FILE' + input_name_test_abs
                                      + ' not found!!!')
    # Delete existing mp4 file
    if os.path.isfile(output_name_abs):
        os.remove(output_name_abs)

    # Shell command split by the shlex utility
    arg = shlex.split('ffmpeg -qscale 5 -r 2 -b 9600 -i '
                      + input_names_abs + ' ' + output_name_abs)

    # The shell command run
    rm.run_script(pics_dir, arg, wait=1, errout=1)

    os.chdir(python_dir)


###############################################################################
#                       Sort indices according to endres                      #
###############################################################################
def indsort(
        which_methods,
        model_name='wavebc',
        which_res='endres',
        stat_method='mean',
        ensemble_sizes=[50, 70, 100, 250],
        ensemble_size=50
):
    """
    Sort the methods specified in which_methods according to an array of
    statistical measures.

    Parameters
    ----------
    which_methods : array int
        Array of integers containing the method specifiers
        from module plotarrays.

    model_name : string
        'wavebc' - Model wavebc
        'wavereal' - Model wavereal
        'wavewell' - Model wavewell
        'wave' - Model wave

    which_res : string
        'endres' - use residuals after EnKF run
        'begres' - use residuals before EnKF run

    stat_method : string
        'mean' - Calculate means
        'std' - Standard deviation
        'stdm' - Standard deviation of the mean
        'median' - Median or 50 Percentile
        'q25' - 25 Percentile
        'q75' - 75 Percentile

    ensemble_sizes : array of integers
        array can typically contain 50, 70, 100, 250,
        500, 1000, 2000

    ensemble_size : integer
        Possibilities: 50, 70, 100, 250, 500, 1000, 2000.
        The ensemble size used for sorting

    Returns
    -------
    which_methods_sorted : array of ints
        Array sorted indices.

    Notes
    -------
    The array containing the statistical measures is loaded according to the
    input of the function. The array should be found in output/errorplot/npy.
    If it is not found, it should be generated using the read-function in
    'mypackage.scripts.errorplot.read'.
    """

    # Name of the array for sorting
    array_name = pm.py_output_filename(
        'errorplot',
        which_res,
        stat_method+'_'+model_name+'_'
        + '_'.join([str(enssize) for enssize in ensemble_sizes])+'_'
        + '_'.join([str(i) for i in which_methods]),
        'npy'
    )

    # Ensure array existence
    if not os.path.isfile(array_name):
        numpy_array, numpy_array_name = er.read(
            which_methods=which_methods,
            ensemble_sizes=ensemble_sizes,
            model=model_name,
            which_res=which_res,
            stat_method=stat_method,
        )
        np.save(numpy_array_name, numpy_array)

    # Index of ensemble size
    iensemble_size = pa.indens[model_name][ensemble_size]

    # Load array
    array = np.load(array_name)[:, iensemble_size]

    # Indices for sorting order
    which_methods_sorted = np.argsort(array)

    return which_methods_sorted
